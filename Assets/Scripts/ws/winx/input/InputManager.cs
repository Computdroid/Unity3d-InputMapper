//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.17929
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;
using System.Text;
using ws.winx.platform;
using System.ComponentModel;
using ws.winx.devices;
using System.Threading;
using System.Runtime.InteropServices;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;



namespace ws.winx.input
{

    public static class InputManager
    {



        
        private static InputSettings __settings;//=new InputSettings();
        private static IHIDInterface __hidInterface;//=new ws.winx.platform.windows.WinHIDInterface();


        private static readonly object syncRoot = new object();


        /// <summary>
        /// Edit Mode = true stops all keys quering and checks of gameplay. Useful when use open UI to map keys to states
        /// 
        /// </summary>
        public static bool EditMode = false;


        public enum Error : ushort
        {

            NoError = 0x0,
            SettingNotLoaded = 0x1,
            //Disposing= 0x4



        }

        public static bool isReady()
        {

            //settings should be loaded
            if (InputManager.__settings == null)
            {
                Debug.LogError("InputSetting not loaded");
                return false;
            }



            return !EditMode;
        }











        public static IHIDInterface hidInterface
        {
            get
            {

                if (__hidInterface == null)
                {
                    //if((Application.platform & (RuntimePlatform.WindowsPlayer | RuntimePlatform.WindowsEditor))!=0){

#if UNITY_STANDALONE_WIN || UNITY_EDITOR_WIN
                    __hidInterface = new ws.winx.platform.windows.WinHIDInterface();
#endif


#if UNITY_STANDALONE_OSX || UNITY_EDITOR_OSX
						__hidInterface=new ws.winx.platform.osx.OSXHIDInterface();
#endif


#if UNITY_WEBPLAYER && !UNITY_EDITOR
						__hidInterface=new ws.winx.platform.web.WebHIDInterface();
#endif

#if UNITY_ANDROID && !UNITY_EDITOR
                          __hidInterface=new ws.winx.platform.android.AndroidHIDInterface();
#endif

                    //register events
                    __hidInterface.DeviceDisconnectEvent += new EventHandler<DeviceEventArgs<string>>(onRemoveDevice);
                    __hidInterface.DeviceConnectEvent += new EventHandler<DeviceEventArgs<IDevice>>(onAddDevice);



                    Debug.Log(__hidInterface.GetType() + " is Initialized");
                }


                //	if(_joysticks==null) _joysticks = new JoystickDevicesCollection(); 



                return __hidInterface;
            }
        }


        internal static void onRemoveDevice(object sender, DeviceEventArgs<string> args)
        {

            lock (syncRoot)
            {
                if (InputEx.Devices.ContainsID(args.data))
                {

                    //remove asigned device from InputPlayer
                    if (__settings != null && __settings.Players != null && __settings.Players.Length > 0)
                    {

                        IDevice device = InputEx.Devices[args.data];

                        //indexOf maybe
                        for (int i = 0; i < __settings.Players.Length; i++)
                        {
                            if (device.Equals(__settings.Players[i].Device))
                            {
                                __settings.Players[i].Device = null;
                                Debug.Log("Device " + args.data + " dettached from Player" + i);
                            }
                        }
                    }

                    InputEx.Devices.Remove(args.data);
                }

            }
        }

        internal static void onAddDevice(object sender, DeviceEventArgs<IDevice> args)
        {

            lock (syncRoot)
            {
                //do not allow duplicates
                if (InputEx.Devices.ContainsID(args.data.ID))
                    return;

                InputEx.Devices[args.data.ID] = args.data;
            }

        }

        public static InputSettings Settings
        {
            get { if (__settings == null) __settings = new InputSettings(); return __settings; }
        }


        /// <summary>
        /// Returns joystick list of Type T (Idea is to get Joystick and set/use some special ablitiy like SetMotor)
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public static List<T> GetDevices<T>()
        {

            lock (syncRoot)
            {
                IDeviceCollection devices = InputEx.Devices;

                List<T> Result = new List<T>();

                foreach (IDevice device in devices)
                {
                    if (device.GetType() == typeof(T) || device is T)
                    {
                        Result.Add((T)device);

                    }

                }



                return Result;
            }
        }

        /// <summary>
        /// Add driver that would support custom device (see WinMMDriver,OSXDriver...for HOW TO)
        /// </summary>
        /// <param name="driver"></param>
        public static void AddDriver(IDriver driver)
        {
            hidInterface.AddDriver(driver);

        }



        /// <summary>
        /// Map state to input on player with index and profile
        /// </summary>
        /// <param name="stateName"></param>
        /// <param name="player"></param>
        /// <param name="at"></param>
        /// <param name="combos"></param>
        public static void MapStateToInput(String stateName, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1, params KeyCode[] combos)
        {

            MapStateToInput(stateName, new InputCombination(combos), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name hash.</param>
        /// <param name="player"></param>
        /// <param name="at">At.</param>
        /// <param name="combos">Combos.</param>
        public static void MapStateToInput(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1, params KeyCode[] combos)
        {

            MapStateToInput(stateNameHash, new InputCombination(combos), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name.</param>
        /// <param name="player"></param>
        /// <param name="at">At.</param>
        /// <param name="combos">Combos.</param>
        public static void MapStateToInput(String stateName, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1, params int[] combos)
        {

            MapStateToInput(stateName, new InputCombination(combos), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name Hash.</param>
        /// <param name="player"></param>
        /// <param name="at">At.</param>
        /// <param name="combos">Combos.</param>
        public static void MapStateToInput(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1, params int[] combos)
        {

            MapStateToInput(stateNameHash, new InputCombination(combos), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name Hash.</param>
        /// <param name="player"></param>
        /// <param name="at">At.</param>
        /// <param name="combos">Actions. KeyExtension.Backspace.DOUBLE,...</param>
        public static void MapStateToInput(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1, params InputAction[] actions)
        {

            MapStateToInput(stateNameHash, new InputCombination(actions), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name .</param>
        /// <param name="player"></param>
        /// <param name="at">At.</param>
        /// <param name="combos">Actions. ex KeyExtension.Backspace.DOUBLE,...</param>
        public static void MapStateToInput(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1, params InputAction[] actions)
        {

            MapStateToInput(stateName, new InputCombination(actions), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name </param>
        /// 
        /// <param name="codeCombination">Code combination.
        /// just "I" for KeyCode.I
        /// or "I"+InputAction.DOUBLE_DESIGNATOR 
        ///	 or "I"+InputAction.DOUBLE_DESIGNATOR+InputAction.SPACE_DESIGNATOR+(other code);
        ///   or just "I(x2)" depending of InputAction.DOUBLE_DESIGNATOR value
        /// </param>
        /// <param name="player"></param>
        /// <param name="at">At.Valid:-1(next) or 0(primary) and 1(secondary)</param>
        public static void MapStateToInput(String stateName, string codeCombination, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1)
        {

            MapStateToInput(stateName, new InputCombination(codeCombination), player, at);

        }

        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateNameHash">State name hash(int) </param>
        /// <param name="player"></param>
        /// <param name="codeCombination">Code combination.
        /// just "I" for KeyCode.I
        /// or "I"+InputAction.DOUBLE_DESIGNATOR 
        ///	 or "I"+InputAction.DOUBLE_DESIGNATOR+InputAction.SPACE_DESIGNATOR+(other code);
        ///   or just "I(x2)" depending of InputAction.DOUBLE_DESIGNATOR value
        /// </param>
        /// <param name="at">At.Valid:-1(next) or 0(primary) and 1(secondary)</param>
        public static void MapStateToInput(int stateNameHash, String codeCombination, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1)
        {

            MapStateToInput(stateNameHash, new InputCombination(codeCombination), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name.</param>
        /// <param name="player"></param>
        /// <param name="combos">Combos (ex. (int)KeyCode.P,(int)KeyCode.Joystick2Button12,JoystickDevice.toCode(...))</param>
        public static void MapStateToInput(String stateName, InputPlayer.Player player = InputPlayer.Player.Player0, params int[] combos)
        {
            MapStateToInput(stateName, new InputCombination(combos), player);
        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name hash.</param>
        /// <param name="player"></param>
        /// <param name="combos">Combos (ex. (int)KeyCode.P,(int)KeyCode.Joystick2Button12,JoystickDevice.toCode(...))</param>
        public static void MapStateToInput(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, params int[] combos)
        {
            MapStateToInput(stateNameHash, new InputCombination(combos), player);
        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name hash.</param>
        /// <param name="player"></param>
        /// <param name="combos">Combos (ex. KeyCodeExtension.Backspace.DOUBLE,KeyCodeExtesnion.Joystick1AxisYPositive.SINGLE)</param>
        public static void MapStateToInput(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, params InputAction[] actions)
        {
            MapStateToInput(stateNameHash, new InputCombination(actions), player);
        }



        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name</param> 
        /// <param name="player"></param>
        /// <param name="combos">Combos (ex. KeyCodeExtension.Backspace.DOUBLE,KeyCodeExtesnion.Joystick1AxisYPositive.SINGLE)</param>
        public static void MapStateToInput(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0, params InputAction[] actions)
        {
            MapStateToInput(stateName, new InputCombination(actions), player);
        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name.</param>
        /// <param name="combination">Combination.</param>    
        /// <param name="player"></param>
        /// <param name="at">At.Valid:-1(next) or 0(primary) and 1(secondary)</param>

        public static void MapStateToInput(string stateName, InputCombination combination, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1)
        {

            if (at > 2) throw new Exception("Only indexes 0(Primary) and 1(Secondary) input are allowed");

            if (!isReady())
                return;

            int stateNameHash = Animator.StringToHash(stateName);
            InputState state;

            if (!__settings.GetInputStatesOfPlayer(player).ContainsKey(stateNameHash))
            {
                //create InputState and add to Dictionary of state inputs
                state = __settings.GetInputStatesOfPlayer(player)[stateNameHash] = new InputState(stateName, stateNameHash);
            }
            else
            {
                state = __settings.GetInputStatesOfPlayer(player)[stateNameHash];
            }

            state.Add(combination, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name hash.</param>
        /// <param name="combination">Combination.</param>
        /// <param name="player"></param>
        /// <param name="player"></param>
        /// <param name="at">At.Valid:-1(next) or 0(primary) and 1(secondary)</param>
        public static void MapStateToInput(int stateNameHash, InputCombination combination, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1)
        {

            if (at > 2) throw new Exception("Only indexes 0(Primary) and 1(Secondary) input are allowed");
            if (!isReady())
                return;

            InputState state;

            if (!__settings.GetInputStatesOfPlayer(player).ContainsKey(stateNameHash))
            {
                //create InputState and add to Dictionary of state inputs
                state = __settings.GetInputStatesOfPlayer(player)[stateNameHash] = new InputState("GenState_" + stateNameHash, stateNameHash);
            }
            else
            {
                state = __settings.GetInputStatesOfPlayer(player)[stateNameHash];
            }

            state.Add(combination, at);

        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="stateNameHash"></param>
        /// <param name="player"></param>
        /// <returns></returns>
        public static bool HasInputState(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0)
        {

            return isReady() && __settings.GetInputStatesOfPlayer(player).ContainsKey(stateNameHash);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stateName"></param>
        /// <param name="player"></param>
        /// <returns></returns>
        public static bool HasInputState(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0)
        {

            return isReady() && InputManager.HasInputState(Animator.StringToHash(stateName), player);
        }


        public static void addEvents(InputEvent[] events, InputPlayer.Player player = InputPlayer.Player.Player0)
        {

            int len = events.Length;

            for (int i = 0; i < len; i++)
                __settings.Players[(int)player].AddEvent(events[i]);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stateNameHash"></param>
        /// <param name="player"></param>
        /// <returns></returns>
        public static InputEvent addEventListener(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0)
        {
            if (isReady())

                return __settings.Players[(int)player].GetEvent(stateNameHash);

            return null;
        }

        /// <summary>
        /// 
        /// </summary>
        internal static void dispatchEvent()
        {

            if (!isReady())
                return;
            int numPlayers = __settings.Players.Length;


            Dictionary<int, InputEvent> stateEvents;


            for (int i = 0; i < numPlayers; i++)
            {
                stateEvents = __settings.Players[i].stateEvents;

                if (stateEvents != null)
                    foreach (var stateInputEventsPair in stateEvents)
                    {

                        if (InputManager.GetInputHold(stateInputEventsPair.Key, i))
                        {
                            stateInputEventsPair.Value.onHOLD.Invoke();
                        }

                        if (InputManager.GetInputDown(stateInputEventsPair.Key, i))
                        {
                            stateInputEventsPair.Value.onDOWN.Invoke();
                        }

                        if (InputManager.GetInputUp(stateInputEventsPair.Key, i))
                        {
                            stateInputEventsPair.Value.onUP.Invoke();
                        }


                    }
            }
        }









		public static InputSettings loadSettingsFromBin(String path)
		{
			
			
			using (Stream stream = new FileStream(path, FileMode.Open, FileAccess.Read))
			{
				BinaryFormatter bf = new BinaryFormatter();
				__settings = (InputManager.InputSettings)bf.Deserialize(stream);
				stream.Close();
			}
			
			return __settings;
		}


        ///!!!! UNITY DOESN"T INCLUDE SYSTEM.XML (OR SOME PARTS OF IT) SO RUNTIME SERIALIZATION DOESN"T WORK IN WEBPLAYER
        /// manual deserialzation is done with addtional methods for WEBPLAYER 
        /// TODO mulitplayer changes for webplayer ser/des should be done if there is interest of community


#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
      




        /// <summary>
        /// Loads the Input settings from InputSettings.xml and deserialize into OO structure.
        /// Create your .xml settings with InputMapper Editor
        /// </summary>
        public static InputSettings loadSettings(String path = "InputSettings.xml")
        {

            if (!File.Exists(path))
            {
                UnityEngine.Debug.LogError("File Not found " + path);
                //return null;
            }

            if (Path.GetExtension(path) != ".xml" && Path.GetExtension(path) != ".bin")
            {
                throw new Exception("Not supported file type. Please use XML or BIN");
                //return null;
            }

            if (Path.GetExtension(path) == ".bin")
            {
                return loadSettingsFromBin(path);

            }


            XmlReaderSettings xmlSettings = new XmlReaderSettings();
            xmlSettings.CloseInput = true;
            xmlSettings.IgnoreWhitespace = true;



            //DataContractSerializer serializer = new DataContractSerializer(typeof(Dictionary<int,InputCombination[]>),"Inputs","");
            DataContractSerializer serializer = new DataContractSerializer(typeof(InputSettings), "Inputs", "");


            using (XmlReader reader = XmlReader.Create(path, xmlSettings))
            {

                __settings = (InputSettings)serializer.ReadObject(reader);

            }



            return __settings;
        }


        public static InputSettings loadSettings(StringReader stringReader)
        {
            XmlReaderSettings xmlSettings = new XmlReaderSettings();
            xmlSettings.CloseInput = true;
            xmlSettings.IgnoreWhitespace = true;




            //DataContractSerializer serializer = new DataContractSerializer(typeof(Dictionary<int,InputCombination[]>),"Inputs","");
            DataContractSerializer serializer = new DataContractSerializer(typeof(InputSettings), "Inputs", "");


            using (XmlReader reader = XmlReader.Create(stringReader, xmlSettings))
            {

                __settings = (InputSettings)serializer.ReadObject(reader);

            }



            return __settings;
        }
#endif


        /// <summary>
        /// Loads the settings from XML text.
        /// </summary>
        /// <returns>The settings from XML text.</returns>
        /// <param name="path">Path.</param>
        /// <param name="readBOM">If set to <c>true</c> read BO.</param>
        public static InputSettings loadSettingsFromXMLText(string path, bool readBOM = true)
        {
            XmlReaderSettings xmlSettings = new XmlReaderSettings();
            xmlSettings.CloseInput = true;
            xmlSettings.IgnoreWhitespace = true;




            using (XmlReader reader = XmlReader.Create(path, xmlSettings))
            {

                if (readBOM)
                    reader.Read();//skip BOM



                readSettings(reader);





            }// UnityEngine.Debug.Log("end reader");

            return __settings;
        }


        /// <summary>
        /// Loads the settings from text.
        /// </summary>
        /// <returns>The settings from text.</returns>
        /// <param name="text">Text.</param>
        /// <param name="readBOM">If set to <c>true</c> read BO.</param>
        public static InputSettings loadSettingsFromText(string text, bool readBOM = true)
        {
            XmlReaderSettings xmlSettings = new XmlReaderSettings();
            xmlSettings.CloseInput = true;
            xmlSettings.IgnoreWhitespace = true;
            StringReader stringReader = new StringReader(text);

            if (readBOM)
                stringReader.Read();//skip BOM

            using (XmlReader reader = XmlReader.Create(stringReader, xmlSettings))
            {


                __settings = new InputSettings();

                readSettings(reader);

                stringReader.Close();



            }// UnityEngine.Debug.Log("end reader");

            return __settings;
        }





#if UNITY_WEBPLAYER && !UNITY_EDITOR
		public static IEnumerator saveSettings(String url){

        //V1
			//WWWForm wwwForm=new WWWForm();
			//wwwForm.AddField("data",formatOutput);

			//WWW www=new WWW(url,wwwForm);

           
            string str=formatOutput();
            byte[] bytes = new byte[str.Length * sizeof(char)];
            System.Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
            WWW www=new WWW(url,bytes);
           
           

			yield return www;

            if(www.error!=null) UnityEngine.Debug.LogError(www.error);
		}

#endif


        internal static void readSettings(XmlReader reader)
        {

            __settings = new InputSettings();

            int key;

            InputAction action;
            List<InputAction> actions = null;
            InputCombination[] combinations = null;
            string name;
            InputState state;
            int i;
            List<InputPlayer> playerList;
            InputPlayer player;
            string profileKey;
            Dictionary<int, InputState> stateInputs;
            //XmlNameTable nameTable = reader.NameTable;
            //XmlNamespaceManager nsManager = new XmlNamespaceManager(nameTable);
            //nsManager.AddNamespace("d1p1", "http://schemas.datacontract.org/2004/07/ws.winx.input");

            reader.ReadToFollowing("d1p1:doubleDesignator");
            __settings.doubleDesignator = reader.ReadElementContentAsString();


            __settings.longDesignator = reader.ReadElementContentAsString();


            __settings.spaceDesignator = reader.ReadElementContentAsString();




            __settings.singleClickSensitivity = reader.ReadElementContentAsFloat();


            __settings.doubleClickSensitivity = reader.ReadElementContentAsFloat();


            __settings.longClickSensitivity = reader.ReadElementContentAsFloat();


            __settings.combinationsClickSensitivity = reader.ReadElementContentAsFloat();






            if (reader.ReadToFollowing("d1p1:InputPlayer"))
            {

                playerList = new List<InputPlayer>();

                do
                {

                    player = new InputPlayer();

                    playerList.Add(player);


                    if (reader.ReadToFollowing("d4p1:KeyValueOfstringArrayOfKeyValuePairOfintInputState"))
                    {


                        do
                        {
                            reader.ReadToDescendant("d4p1:Key");

                            profileKey = reader.ReadElementContentAsString();



                            if (reader.ReadToFollowing("d4p1:KeyValueOfintInputState"))
                            {

                                stateInputs = new Dictionary<int, InputState>();

                                do
                                {




                                    reader.ReadToDescendant("d4p1:Key");

                                    key = reader.ReadElementContentAsInt();




                                    if (reader.ReadToFollowing("d1p1:InputCombination"))
                                    {

                                        combinations = new InputCombination[2];
                                        i = 0;

                                        do
                                        {
                                            if (reader.GetAttribute("i:nil") == null)
                                            {


                                                if (reader.ReadToDescendant("d1p1:InputAction"))
                                                {
                                                    actions = new List<InputAction>();

                                                    do
                                                    {
                                                        reader.ReadToDescendant("d1p1:Code");

                                                        action = new InputAction(reader.ReadElementContentAsString());

                                                        actions.Add(action);

                                                    } while (reader.ReadToNextSibling("d1p1:InputAction"));


                                                }




                                                combinations[i++] = new InputCombination(actions);

                                                reader.Read();//read </InputCombination>

                                            }



                                        } while (reader.ReadToNextSibling("d1p1:InputCombination"));



                                    }

                                    reader.ReadToFollowing("d1p1:Name");
                                    name = reader.ReadElementContentAsString();
                                    state = new InputState(name, key);
                                    state.combinations = combinations;


                                    //Shound be extended to multiplayer expansion
                                    stateInputs[key] = state;


                                    reader.Read();//</d4p1:KeyValueOfintInputState>

                                } while (reader.ReadToNextSibling("d4p1:KeyValueOfintInputState"));

                                player.DeviceProfileStateInputs[profileKey] = stateInputs;

                            }//




                            reader.Read();//</d4p1:KeyValueOfstringArrayOfKeyValuePairOfintInputState>

                        } while (reader.ReadToNextSibling("d4p1:KeyValueOfstringArrayOfKeyValuePairOfintInputState"));



                    }

                    if (reader.ReadToFollowing("d1p1:_deviceID") && reader.GetAttribute("i:nil") == null)
                    {
                        player.DeviceID = reader.ReadElementContentAsString();
                    }

                    if (reader.ReadToFollowing("d1p1:Name") && reader.GetAttribute("i:nil") == null)
                    {
                        player.Name = reader.ReadElementContentAsString();
                    }
                    else



                        reader.Read();//</d1p1:InputPlayer>

                } while (reader.ReadToNextSibling("d1p1:InputPlayer"));


                __settings.Players = playerList.ToArray();
            }


        }

        public static string formatOutput()
        {





            string HEADFORMAT = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
   "<Inputs xmlns:d1p1=\"http://schemas.datacontract.org/2004/07/ws.winx.input\" xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\">" +
    " <d1p1:doubleDesignator>{0}</d1p1:doubleDesignator>" +
    " <d1p1:longDesignator>{1}</d1p1:longDesignator>" +
    " <d1p1:spaceDesignator>{2}</d1p1:spaceDesignator>" +
    " <d1p1:singleClickSensitivity>{3}</d1p1:singleClickSensitivity>" +
    " <d1p1:doubleClickSensitivity>{4}</d1p1:doubleClickSensitivity>" +
   "  <d1p1:longClickSensitivity>{5}</d1p1:longClickSensitivity>" +
   "  <d1p1:combinationsClickSensitivity>{6}</d1p1:combinationsClickSensitivity>" +
    "<d1p1:Players>" +

    " {7}" +
                    "</d1p1:Players>" +
   "</Inputs>";

            string EMPTY_TAG_FORMAT = "<d1p1:{0} i:nil=\"true\" />";
            string TAG_FORMAT = "<d1p1:{0}>{1}<d1p1:{0}/>";


            string PROFILEFORMAT =
                                 "<d4p1:KeyValueOfstringArrayOfKeyValuePairOfintInputState>"
                                + "<d4p1:Key>{0}</d4p1:Key>"
                                + "<d4p1:Value>"
                                + "{1}</d4p1:Value>"
                    + "</d4p1:KeyValueOfstringArrayOfKeyValuePairOfintInputState>";


            string DEVICE_STATES_INPUTS_FORMAT =
                "<d1p1:_DeviceStateInputs xmlns:d4p1=\"http://schemas.microsoft.com/2003/10/Serialization/Arrays\">" +
                "{0}" +
                    "</d1p1:_DeviceStateInputs>";

            string INPUTPLAYER =
            "<d1p1:InputPlayer>" +
            "{0}" +
            "</d1p1:InputPlayer>";

            string STATEFORMAT = " <d4p1:KeyValueOfintInputState>" +
                                    " <d4p1:Key>{0}</d4p1:Key>" +
                                  " <d4p1:Value>" +
                                   "  <d1p1:Hash>{0}</d1p1:Hash>" +
                                    " <d1p1:InputCombinations>" +
                                       " {1}" +

                                    " </d1p1:InputCombinations>" +
                                   "  <d1p1:Name>{2}</d1p1:Name>" +
                                  " </d4p1:Value>" +
                                 "</d4p1:KeyValueOfintInputState>";


            string COMBINATIONFORMAT =
                    "   <d1p1:InputCombination>" +
                   "     <d1p1:InputActions>" +
                  "{0}" +
                   "     </d1p1:InputActions>" +
                  "   </d1p1:InputCombination>";

            string ACTIONFORMAT =
                       "       <d1p1:InputAction>" +
                 "         <d1p1:Code>{0}</d1p1:Code>" +
                   "       </d1p1:InputAction>";
            string actionsString;


            Dictionary<int, InputState> stateInputs;// = InputManager.Settings.stateInputs;
            InputCombination[] combinations;
            InputCombination combination;

            int key;
            StringBuilder statesSB = new StringBuilder(10000);
            StringBuilder combinationSB = new StringBuilder(100);
            StringBuilder profilesSB = new StringBuilder(100000);
            StringBuilder playersSB = new StringBuilder(100000);

            int numPlayers = __settings.Players.Length;
            InputPlayer player;
            for (int playerInx = 0; playerInx < numPlayers; playerInx++)
            {

                player = __settings.Players[playerInx];

                profilesSB.Length = 0;

                foreach (KeyValuePair<string, Dictionary<int, InputState>> profileStateInput in player.DeviceProfileStateInputs)
                {

                    stateInputs = profileStateInput.Value;

                    statesSB.Length = 0;

                    foreach (KeyValuePair<int, InputState> stateInput in stateInputs)
                    {
                        key = stateInput.Key;
                        combinations = stateInput.Value.combinations;

                        combinationSB.Length = 0;


                        if ((combination = combinations[0]) != null)
                        {
                            actionsString = "";

                            foreach (InputAction action in combination.actionsList)
                            {
                                actionsString += String.Format(ACTIONFORMAT, action.ToString());
                            }

                            combinationSB.AppendFormat(COMBINATIONFORMAT, actionsString);
                        }

                        if ((combination = combinations[1]) != null)
                        {
                            actionsString = "";
                            foreach (InputAction action in combination.actionsList)
                            {
                                actionsString += String.Format(ACTIONFORMAT, action.ToString());
                            }

                            combinationSB.AppendFormat(COMBINATIONFORMAT, actionsString);
                        }


                        statesSB.AppendFormat(STATEFORMAT, key, combinationSB.ToString(), stateInput.Value.name);


                    }//StateInputs

                    profilesSB.AppendFormat(PROFILEFORMAT, profileStateInput.Key, statesSB.ToString());

                }//DeviceProfileStateInputs

                statesSB.Length = 0;
                statesSB.AppendFormat(DEVICE_STATES_INPUTS_FORMAT, profilesSB.ToString());

                if (!String.IsNullOrEmpty(player.DeviceID))
                {
                    statesSB.AppendFormat(TAG_FORMAT, "_deviceID", player.DeviceID);
                }
                else
                {
                    statesSB.AppendFormat(EMPTY_TAG_FORMAT, "_deviceID");
                }

                if (!String.IsNullOrEmpty(player.Name))
                {
                    statesSB.AppendFormat(TAG_FORMAT, "Name", player.Name);
                }
                else
                {
                    statesSB.AppendFormat(EMPTY_TAG_FORMAT, "Name");
                }

                playersSB.AppendFormat(INPUTPLAYER, statesSB.ToString());



            }//players


            return String.Format(HEADFORMAT, __settings.doubleDesignator, __settings.longDesignator, __settings.spaceDesignator, __settings.singleClickSensitivity, __settings.doubleClickSensitivity, __settings.longClickSensitivity, __settings.combinationsClickSensitivity,
                                playersSB.ToString());
        }


#if UNITY_WEBPLAYER && UNITY_EDITOR
       public static void saveSettings(string path){
           XmlWriterSettings xmlSettings = new XmlWriterSettings();
           xmlSettings.Indent = true;
           xmlSettings.CloseOutput = true;//this would close stream after write 
          




           using (XmlWriter writer = XmlWriter.Create(path, xmlSettings))
           {
             
               writer.WriteRaw( formatOutput());
               



               //Write the XML to file and close the writer.
               writer.Flush();
               writer.Close();


           }


			Debug.Log(InputManager.Log());
       }
#endif

        internal static void saveSettingsBin(String path)
        {
            using (FileStream ms = new FileStream(path, FileMode.Create, FileAccess.Write))
            {
                var bin = new BinaryFormatter();
                bin.Serialize(ms, __settings);
                ms.Flush();
                ms.Close();
            }
        }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID)&& !UNITY_WEBPLAYER
        /// <summary>
        /// Saves the settings to InputSettings.xml.
        /// </summary>
        public static void saveSettings(String path)
        {
            if (Path.GetExtension(path) == ".bin")
            {
                saveSettingsBin(path);
                return;

            }



            //DataContractSerializer serializer = new DataContractSerializer(typeof(Dictionary<int,InputCombination[]>),"Inputs","");

            DataContractSerializer serializer = new DataContractSerializer(typeof(InputSettings), "Inputs", "");


            XmlWriterSettings xmlSettings = new XmlWriterSettings();
            xmlSettings.Indent = true;
            xmlSettings.CloseOutput = true;//this would close stream after write 
            //	xmlSettings.IndentChars="\t";
            //	xmlSettings.NewLineOnAttributes = false;
            //	xmlSettings.OmitXmlDeclaration = true;





            using (XmlWriter writer = XmlWriter.Create(path, xmlSettings))
            {
                //serializer.WriteObject(writer, __settings.stateInputs);
                serializer.WriteObject(writer, __settings);

                //Write the XML to file and close the writer.
                writer.Flush();
                writer.Close();


            }



        }

#endif

        public static void processGUIEvent(Event current)
        {
            InputEx.processGUIEvent(current);
        }






        //public void resetMap(){
        //}


        /// <summary>
        /// Gets action from IDevice or if null
        /// gets the action that happens on any keyboard,mouse or game controller input.(useful for building user mapping interface)
        /// </summary>
        /// <returns>The action.</returns>
        /// <param name="">.</param>
        public static InputAction GetAction(IDevice device)
        {
            if (__settings != null)
                return InputEx.GetAction(device);
            else
                return null;
        }




        /// <summary>
        /// Gets the input of generic created values in range 0f to +/-1f
        /// in steps defined with "sensitivity" param
        /// while key, button,mouse,axis being HOLD
        /// </summary>
        /// <returns> 0f to +/-1f</returns>
        /// <param name="stateNameHash">State name hash.</param>
        /// <param name="player"></param>
        /// <param name="sensitivity">Sensitivity of rising value 0f to 1f</param>
        /// <param name="dreadzone">Dreadzone.If value drop under dreadzone value would be nullify</param>
        /// <param name="gravity">Gravity. After no signal from input value would drop with step of gravity or immidiately</param>
        public static float GetInput(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, float sensitivity = 0.1f, float dreadzone = 0.1f, float gravity = 0.3f)
        {
            //Use is mapping states so no quering keys during gameplay
            if (!InputManager.isReady()) return 0f;

            
            InputCombination[] __inputCombinations = __settings.GetInputStatesOfPlayer(player)[stateNameHash].combinations;

            IDevice device = __settings.Players[(int)player].Device;

            return Mathf.Clamp(__inputCombinations[0].GetInputGenerated(device, sensitivity, dreadzone, gravity) + (__inputCombinations.Length == 2 && __inputCombinations[1] != null ? __inputCombinations[1].GetInputGenerated(device, sensitivity, dreadzone, gravity) : 0), -1f, 1f);

        }

        /// <summary>
        /// Gets the input.
        /// </summary>
        /// <returns>The input.</returns>
        /// <param name="stateName">State name.</param>
        /// <param name="player">Player.</param>
        /// <param name="sensitivity">Sensitivity.</param>
        /// <param name="dreadzone">Dreadzone.</param>
        /// <param name="gravity">Gravity.</param>
        public static float GetInput(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0, float sensitivity = 0.1f, float dreadzone = 0.1f, float gravity = 0.3f)
        {
            return GetInput(Animator.StringToHash(stateName), player, sensitivity, dreadzone, gravity);
        }



        /// <summary>
        /// Gets the input of device(hardware)
        /// if device's input mapped is digital would return -1f to 1f generic values emulating analog hardware 
        /// if device's input mapped is analog would return 0f to 1f(positive axis) or 0f to -1f(negative axis) 
        /// full axis -1f to 1f
        /// </summary>
        /// <param name="stateNameHash">State name hash.</param>
        /// <param name="player"></param>
        /// <param name="sensitivity">Sensitivity of rising value 0f to 1f</param>
        /// <param name="dreadzone">Dreadzone.If value drop under dreadzone value would be nullify</param>
        /// <param name="gravity">Gravity. After no signal from input value would drop with step of gravity or immidiately</param>
        /// 
        public static float GetInputRaw(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, float sensitivity = 0.1f, float dreadzone = 0.1f, float gravity = 0.3f)
        {
            //Use is mapping states so no quering keys during gameplay
            if (!InputManager.isReady()) return 0f;

            InputCombination[] inputCombinations = __settings.GetInputStatesOfPlayer(player)[stateNameHash].combinations;

            IDevice device = __settings.Players[(int)player].Device;

            return Mathf.Clamp(inputCombinations[0].GetAnalogValue(device, sensitivity, dreadzone, gravity) + (inputCombinations.Length == 2 && inputCombinations[1] != null ? inputCombinations[1].GetAnalogValue(device, sensitivity, dreadzone, gravity) : 0f), -1f, 1f);

        }

        /// <summary>
        /// [Use for testing as string to hash is slow operat
        /// Gets the input of device(hardware)
        /// if device's input mapped is digital would return -1f to 1f generic values emulating analog hardware 
        /// if device's input mapped is analog would return 0f to 1f(positive axis) or 0f to -1f(negative axis) 
        /// full axis -1f to 1f
        /// </summary>
        /// <returns>The input raw.</returns>
        /// <param name="stateNameHash">State name hash.</param>
        /// <param name="player">Player.</param>
        /// <param name="sensitivity">Sensitivity.</param>
        /// <param name="dreadzone">Dreadzone.</param>
        /// <param name="gravity">Gravity.</param>
        public static float GetInputRaw(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0, float sensitivity = 0.1f, float dreadzone = 0.1f, float gravity = 0.3f)
        {
            return GetInputRaw(Animator.StringToHash(stateName), player, sensitivity, dreadzone, gravity);
        }


        /// <summary>
        /// HOLD.
        /// </summary>
        /// <returns><c>true</c>, while input binded to state returns signal, <c>false</c> otherwise.</returns>
        /// <param name="stateNameHash">State name hash.</param>
        /// <param name="playerIndex">Player index.</param>
        internal static bool GetInputHold(int stateNameHash, int playerIndex)
        {

            //Use is mapping states so no quering keys during gameplay
            if (!InputManager.isReady()) return false;

            InputCombination[] inputCombinations = __settings.GetInputStatesOfPlayer(playerIndex)[stateNameHash].combinations;

            IDevice device = __settings.Players[playerIndex].Device;

            return inputCombinations[0].GetInputHold(device) || (inputCombinations.Length == 2 && inputCombinations[1] != null && inputCombinations[1].GetInputHold(device));

        }


        /// <summary>
        /// HOLD.
        /// </summary>
        /// <returns><c>true</c>, while input binded to state returns signal, <c>false</c> otherwise.</returns>
        /// <param name="stateNameHash">State name hash.</param>
        /// <param name="player">Player.</param>
        public static bool GetInputHold(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0)
        {
            return GetInputHold(stateNameHash, (int)player);
        }



        /// <summary>
        /// HOLD.[Use for testing as string to hash is slow operat
        /// </summary>
        /// <returns><c>true</c>, while input binded to state returns signal, <c>false</c> otherwise.</returns>
        /// <returns><c>true</c>, if input hold was gotten, <c>false</c> otherwise.</returns>
        /// <param name="stateName">State name.</param>
        /// <param name="player">Player.</param>
        public static bool GetInputHold(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0)
        {
            return GetInputHold(Animator.StringToHash(stateName), player);
        }




        internal static bool GetInputUp(int stateNameHash, int playerIndex = 0)
        {
            //Use is mapping states so no quering keys during gameplay
            if (!InputManager.isReady()) return false;

            InputCombination[] inputCombinations = __settings.GetInputStatesOfPlayer(playerIndex)[stateNameHash].combinations;


            IDevice device = __settings.Players[playerIndex].Device;
            return inputCombinations[0].GetInputUp(device) || (inputCombinations.Length == 2 && inputCombinations[1] != null && inputCombinations[1].GetInputUp(device));

        }

        /// <summary>
        /// UP.
        /// </summary>
        /// <returns><c>true</c>, if input binded to state stopped to return values(then is reseted), <c>false</c> otherwise.</returns>
        /// <param name="stateNameHash">State name hash.</param>
        /// <param name="player"></param>
        public static bool GetInputUp(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0)
        {
            return GetInputUp(stateNameHash, (int)player);
        }


        /// <summary>
        /// UP.[Use for testing as string to hash is slow operation in loop]
        /// </summary>
        /// <returns><c>true</c>, if input binded to state stopped to return values(then is reseted), <c>false</c> otherwise.</returns>
        /// <param name="stateName">State name.</param>
        /// <param name="player">Player.</param>
        public static bool GetInputUp(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0)
        {
            return GetInputUp(Animator.StringToHash(stateName), player);
        }


        /// <summary>
        /// Gets the input down.
        /// </summary>
        /// <returns><c>true</c>, if input down was gotten, <c>false</c> otherwise.</returns>
        /// <param name="stateNameHash">State name hash.</param>
        /// <param name="playerIndex">Player index.</param>
        /// <param name="atOnce">If set to <c>true</c> at once.</param>
        internal static bool GetInputDown(int stateNameHash, int playerIndex = 0, bool atOnce = false)
        {
            //Use is mapping states so no quering keys during gameplay
            if (!InputManager.isReady()) return false;

            InputCombination[] inputCombinations = __settings.GetInputStatesOfPlayer(playerIndex)[stateNameHash].combinations;

            IDevice device = __settings.Players[playerIndex].Device;

            return inputCombinations[0].GetInputDown(device, atOnce) || (inputCombinations.Length == 2 && inputCombinations[1] != null && inputCombinations[1].GetInputDown(device, atOnce));
        }



        /// <summary>
        /// DOWN.
        /// </summary>
        /// <returns><c>true</c>, if input binded to state started to return values (than is reseted), <c>false</c> otherwise.</returns>
        /// <param name="stateNameHash">State name hash.</param>
        /// <param name="player"></param>
        /// <param name="atOnce">(combos effective only) default=<c>false</c> expect combo parts successive action (ex. W+C => W pressed,released then C pressed)
        /// atOnce=true useful for building modifires like behaviour (LeftCtrl(-)+C)</param>	
        public static bool GetInputDown(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, bool atOnce = false)
        {
            return GetInputDown(stateNameHash, (int)player, atOnce);
        }


        /// <summary>
        /// DOWN.[Use for testing as string to hash is slow operation in loop]
        /// </summary>
        /// <returns><c>true</c>, if input binded to state started to return values (than is reseted), <c>false</c> otherwise.</returns>
        /// <param name="stateName">State name.</param>
        /// <param name="player">Player.</param>
        /// <param name="atOnce">If set to <c>true</c> at once.</param>
        public static bool GetInputDown(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0, bool atOnce = false)
        {
            return GetInputDown(Animator.StringToHash(stateName), player, atOnce);
        }

        /// <summary>
        /// Log states - inputs values to console
        /// </summary>
        public static string Log()
        {
            StringBuilder content = new StringBuilder();
            int i;
            int j;
            //primary,secondary...
            InputCombination[] combinations;

            for (j = 0; j < __settings.Players.Length; j++)
                foreach (var keyValuPair in __settings.GetInputStatesOfPlayer((InputPlayer.Player)j))
                {
                    content.AppendLine("Name:" + keyValuPair.Value.name + " Key:" + keyValuPair.Key);
                    combinations = keyValuPair.Value.combinations;

                    for (i = 0; i < combinations.Length; i++)
                    {
                        if (combinations[i] != null)
                            content.AppendLine(i + ": " + combinations[i].ToString());
                    }

                    content.AppendLine();


                }


            return content.ToString();

        }









        public static void Dispose()
        {

            Debug.Log("InputManager Dispose");

            if (__hidInterface != null)
            {
                Debug.Log("Try to remove HidInterface events");

                __hidInterface.DeviceDisconnectEvent -= new EventHandler<DeviceEventArgs<string>>(onRemoveDevice);


                __hidInterface.DeviceConnectEvent -= new EventHandler<DeviceEventArgs<IDevice>>(onAddDevice);


                __hidInterface.Dispose();
                __hidInterface = null;
            }

            int error = Marshal.GetLastWin32Error();
            if (error > 0)

                UnityEngine.Debug.Log(" Win32Error Erorr" + error);

           // lock (syncRoot)
           // {
                if (InputEx.Devices != null)
                {
                    Debug.Log("Try to remove devices");

                    InputEx.Devices.Clear();


                }
           // }


            Debug.Log("Try to remove states per player");
            if (InputManager.__settings != null)
            {

                InputPlayer[] players = InputManager.__settings.Players;

                if (players != null)
                    for (int i = 0; i < players.Length; i++)
                    {

                        foreach (var DeviceStateInputPair in players[i].DeviceProfileStateInputs)
                        {
                            DeviceStateInputPair.Value.Clear();

                        }


                        players[i].DeviceProfileStateInputs.Clear();

                    }



                InputManager.__settings = null;
            }

            Debug.Log("Dispose Finished");


            if (error > 0)

                UnityEngine.Debug.Log(" Win32Error Erorr" + error);
        }



        #region Settings

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
        [DataContract]
#endif
        [System.Serializable]
        public class InputSettings
        {




#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 4)]
#endif
            public float singleClickSensitivity
            {
                get { return InputAction.SINGLE_CLICK_SENSITIVITY; }
                set { InputAction.SINGLE_CLICK_SENSITIVITY = value; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 5)]
#endif
            public float doubleClickSensitivity
            {
                get { return InputAction.DOUBLE_CLICK_SENSITIVITY; }
                set { InputAction.DOUBLE_CLICK_SENSITIVITY = value; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 6)]
#endif
            public float longClickSensitivity
            {
                get { return InputAction.LONG_CLICK_SENSITIVITY; }
                set { InputAction.LONG_CLICK_SENSITIVITY = value; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 7)]
#endif
            public float combinationsClickSensitivity
            {
                get { return InputAction.COMBINATION_CLICK_SENSITIVITY; }
                set { InputAction.COMBINATION_CLICK_SENSITIVITY = value; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 1)]
#endif
            public string doubleDesignator
            {
                get { return InputAction.DOUBLE_DESIGNATOR; }
                set { InputAction.DOUBLE_DESIGNATOR = value; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 2)]
#endif
            public string longDesignator
            {
                get { return InputAction.LONG_DESIGNATOR; }
                set { InputAction.LONG_DESIGNATOR = value; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 3)]
#endif
            public string spaceDesignator
            {
                get { return InputAction.SPACE_DESIGNATOR.ToString(); }
                set { InputAction.SPACE_DESIGNATOR = value[0]; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Name = "Players", Order = 9)]
#endif
            protected InputPlayer[] _players;

            public InputPlayer[] Players
            {
                get { return _players; }
                set { _players = value; }
            }



            internal Dictionary<int, InputState> GetInputStatesOfPlayer(InputPlayer.Player player)
            {
                return GetInputStatesOfPlayer((int)player);

            }


            internal Dictionary<int, InputState> GetInputStatesOfPlayer(int index)
            {


                InputPlayer player = _players[index];

                //if there is device attached to player
                if (player.Device != null)
                {
                    string profileName = player.Device.profile != null ? player.Device.profile.Name : "default";

                    if (player.DeviceProfileStateInputs.ContainsKey(profileName))
                    {
                        return player.DeviceProfileStateInputs[profileName];

                    }

                }

                return player.DeviceProfileStateInputs["default"];


            }





            //			#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            //			[DataMember(Name="StateInputs",Order=9)]
            //			#endif
            //			protected Dictionary<int,InputState> _stateInputs;

            //public Dictionary<int,InputState> stateInputs{
            //    get {return GetInputStatesOfPlayer(InputManager.currentPlayerIndex);}
            //}


            public InputSettings()
            {
                //_stateInputs=new Dictionary<int,InputState>();

            }
        }
        #endregion







    }
}


